<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OnePos: NVM driver EEPROM handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OnePos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">NVM driver EEPROM handling</div>  </div>
<div class="ingroups"><a class="el" href="group__nvm__group.html">NVM service</a></div></div><!--header-->
<div class="contents">

<p>Functions for handling internal EEPROM memory.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9adfe2ae9400336ec4a715b2db1c3e79"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga9adfe2ae9400336ec4a715b2db1c3e79">eeprom_addr_t</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5f2c4c625ef21cd65891d480f7e6e6b6"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga5f2c4c625ef21cd65891d480f7e6e6b6">nvm_eeprom_read_byte</a> (<a class="el" href="group__nvm__eeprom__group.html#ga9adfe2ae9400336ec4a715b2db1c3e79">eeprom_addr_t</a> addr)</td></tr>
<tr class="memdesc:ga5f2c4c625ef21cd65891d480f7e6e6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one byte from EEPROM using mapped access.  <a href="#ga5f2c4c625ef21cd65891d480f7e6e6b6"></a><br/></td></tr>
<tr class="memitem:ga723a1c1ef60ffb4d220f28c99e6c3014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga723a1c1ef60ffb4d220f28c99e6c3014">nvm_eeprom_read_buffer</a> (<a class="el" href="group__nvm__eeprom__group.html#ga9adfe2ae9400336ec4a715b2db1c3e79">eeprom_addr_t</a> address, void *buf, uint16_t len)</td></tr>
<tr class="memdesc:ga723a1c1ef60ffb4d220f28c99e6c3014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read buffer within the eeprom.  <a href="#ga723a1c1ef60ffb4d220f28c99e6c3014"></a><br/></td></tr>
<tr class="memitem:ga683292d1a734f3222e18720ac66f2315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga683292d1a734f3222e18720ac66f2315">nvm_eeprom_write_byte</a> (<a class="el" href="group__nvm__eeprom__group.html#ga9adfe2ae9400336ec4a715b2db1c3e79">eeprom_addr_t</a> address, uint8_t value)</td></tr>
<tr class="memdesc:ga683292d1a734f3222e18720ac66f2315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one byte to EEPROM using IO mapping.  <a href="#ga683292d1a734f3222e18720ac66f2315"></a><br/></td></tr>
<tr class="memitem:gac913bbba11570b56b639682e7edf8327"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#gac913bbba11570b56b639682e7edf8327">nvm_eeprom_erase_and_write_buffer</a> (<a class="el" href="group__nvm__eeprom__group.html#ga9adfe2ae9400336ec4a715b2db1c3e79">eeprom_addr_t</a> address, const void *buf, uint16_t len)</td></tr>
<tr class="memdesc:gac913bbba11570b56b639682e7edf8327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write buffer within the eeprom.  <a href="#gac913bbba11570b56b639682e7edf8327"></a><br/></td></tr>
<tr class="memitem:ga309765606eafd344378f1ddd20fc4129"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga309765606eafd344378f1ddd20fc4129">nvm_eeprom_flush_buffer</a> (void)</td></tr>
<tr class="memdesc:ga309765606eafd344378f1ddd20fc4129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush temporary EEPROM page buffer.  <a href="#ga309765606eafd344378f1ddd20fc4129"></a><br/></td></tr>
<tr class="memitem:ga47aaaec22fa50f0cfb90657357885fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga47aaaec22fa50f0cfb90657357885fa9">nvm_eeprom_load_byte_to_buffer</a> (uint8_t byte_addr, uint8_t value)</td></tr>
<tr class="memdesc:ga47aaaec22fa50f0cfb90657357885fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load single byte into temporary page buffer.  <a href="#ga47aaaec22fa50f0cfb90657357885fa9"></a><br/></td></tr>
<tr class="memitem:ga02f10adbf959b8525bbaf777ad6e43b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga02f10adbf959b8525bbaf777ad6e43b6">nvm_eeprom_load_page_to_buffer</a> (const uint8_t *values)</td></tr>
<tr class="memdesc:ga02f10adbf959b8525bbaf777ad6e43b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load entire page into temporary EEPROM page buffer.  <a href="#ga02f10adbf959b8525bbaf777ad6e43b6"></a><br/></td></tr>
<tr class="memitem:ga6f939f98287b320d39418ed72ba8cfe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga6f939f98287b320d39418ed72ba8cfe1">nvm_eeprom_atomic_write_page</a> (uint8_t page_addr)</td></tr>
<tr class="memdesc:ga6f939f98287b320d39418ed72ba8cfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase and write bytes from page buffer into EEPROM.  <a href="#ga6f939f98287b320d39418ed72ba8cfe1"></a><br/></td></tr>
<tr class="memitem:gae8b5ca90e2d370109bed6e6adc8d9307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#gae8b5ca90e2d370109bed6e6adc8d9307">nvm_eeprom_split_write_page</a> (uint8_t page_addr)</td></tr>
<tr class="memdesc:gae8b5ca90e2d370109bed6e6adc8d9307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write (without erasing) EEPROM page.  <a href="#gae8b5ca90e2d370109bed6e6adc8d9307"></a><br/></td></tr>
<tr class="memitem:ga6228a0fc4ddfe85c4b6c7b032f81e0df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga6228a0fc4ddfe85c4b6c7b032f81e0df">nvm_eeprom_fill_buffer_with_value</a> (uint8_t value)</td></tr>
<tr class="memdesc:ga6228a0fc4ddfe85c4b6c7b032f81e0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill temporary EEPROM page buffer with value.  <a href="#ga6228a0fc4ddfe85c4b6c7b032f81e0df"></a><br/></td></tr>
<tr class="memitem:gaf2f736b02cc1a2d7e27f45d0d5cc9bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#gaf2f736b02cc1a2d7e27f45d0d5cc9bcb">nvm_eeprom_erase_bytes_in_page</a> (uint8_t page_addr)</td></tr>
<tr class="memdesc:gaf2f736b02cc1a2d7e27f45d0d5cc9bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase bytes from EEPROM page.  <a href="#gaf2f736b02cc1a2d7e27f45d0d5cc9bcb"></a><br/></td></tr>
<tr class="memitem:ga75f4e0c9419252c81387e79356433bca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga75f4e0c9419252c81387e79356433bca">nvm_eeprom_erase_page</a> (uint8_t page_addr)</td></tr>
<tr class="memdesc:ga75f4e0c9419252c81387e79356433bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase EEPROM page.  <a href="#ga75f4e0c9419252c81387e79356433bca"></a><br/></td></tr>
<tr class="memitem:ga0d4308eb16bb32a0a522744a28f5969e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#ga0d4308eb16bb32a0a522744a28f5969e">nvm_eeprom_erase_bytes_in_all_pages</a> (void)</td></tr>
<tr class="memdesc:ga0d4308eb16bb32a0a522744a28f5969e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase bytes from all EEPROM pages.  <a href="#ga0d4308eb16bb32a0a522744a28f5969e"></a><br/></td></tr>
<tr class="memitem:gac87e872a5b79f534b409735066514274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvm__eeprom__group.html#gac87e872a5b79f534b409735066514274">nvm_eeprom_erase_all</a> (void)</td></tr>
<tr class="memdesc:gac87e872a5b79f534b409735066514274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase entire EEPROM memory.  <a href="#gac87e872a5b79f534b409735066514274"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Functions for handling internal EEPROM memory. </p>
<p>The internal EEPROM can be used to store data that will persist after power is removed. This can typically be used to store calibration data, application state, encryption keys or other data that need to be preserved when power is removed.</p>
<p>The functions in this module uses IO register access to manipulate the EEPROM.</p>
<dl class="section note"><dt>Note:</dt><dd>The functions in this module are modifying the NVM.CMD register. If the application are using program space access in interrupts (__flash pointers in IAR EW or pgm_read_byte in GCC) interrupts needs to be disabled when running EEPROM access functions. If not the program space reads will be corrupted. </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga9adfe2ae9400336ec4a715b2db1c3e79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="group__nvm__eeprom__group.html#ga9adfe2ae9400336ec4a715b2db1c3e79">eeprom_addr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type for holding eeprom memory addresses. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6f939f98287b320d39418ed72ba8cfe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_atomic_write_page </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>page_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase and write bytes from page buffer into EEPROM. </p>
<p>This function writes the contents of an already loaded EEPROM page buffer into EEPROM memory.</p>
<p>As this is an atomic write, the page in EEPROM will be erased automatically before writing. Note that only the page buffer locations that have been loaded will be used when writing to EEPROM. Page buffer locations that have not been loaded will be left untouched in EEPROM.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_addr</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac87e872a5b79f534b409735066514274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_erase_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase entire EEPROM memory. </p>
<p>This function erases the entire EEPROM memory block to 0xFF. </p>

</div>
</div>
<a class="anchor" id="gac913bbba11570b56b639682e7edf8327"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_erase_and_write_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvm__eeprom__group.html#ga9adfe2ae9400336ec4a715b2db1c3e79">eeprom_addr_t</a>&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write buffer within the eeprom. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>the address to where to write </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to the data </td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0d4308eb16bb32a0a522744a28f5969e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_erase_bytes_in_all_pages </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase bytes from all EEPROM pages. </p>
<p>This function erases bytes from all EEPROM pages, so that every location written to in the page buffer reads 0xFF. </p>

</div>
</div>
<a class="anchor" id="gaf2f736b02cc1a2d7e27f45d0d5cc9bcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_erase_bytes_in_page </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>page_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase bytes from EEPROM page. </p>
<p>This function erases bytes from one EEPROM page, so that every location written to in the page buffer reads 0xFF.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_addr</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75f4e0c9419252c81387e79356433bca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_erase_page </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>page_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase EEPROM page. </p>
<p>This function erases one EEPROM page, so that every location reads 0xFF.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_addr</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6228a0fc4ddfe85c4b6c7b032f81e0df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_fill_buffer_with_value </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill temporary EEPROM page buffer with value. </p>
<p>This fills the the EEPROM page buffers with a given value. If memory mapped EEPROM is enabled, this function will not work.</p>
<dl class="section note"><dt>Note:</dt><dd>Only the lower part of the address is used to address the buffer. Therefore, no address parameter is needed. In the end, the data is written to the EEPROM page given by the address parameter to the EEPROM write page operation.</dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to copy to the page buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga309765606eafd344378f1ddd20fc4129"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_flush_buffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush temporary EEPROM page buffer. </p>
<p>This function flushes the EEPROM page buffers. This function will cancel any ongoing EEPROM page buffer loading operations, if any. This function also works for memory mapped EEPROM access.</p>
<dl class="section note"><dt>Note:</dt><dd>An EEPROM write operations will automatically flush the buffer for you. </dd>
<dd>
The function does not preserve the value of the NVM.CMD register </dd></dl>

</div>
</div>
<a class="anchor" id="ga47aaaec22fa50f0cfb90657357885fa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_load_byte_to_buffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load single byte into temporary page buffer. </p>
<p>This function loads one byte into the temporary EEPROM page buffers. If memory mapped EEPROM is enabled, this function will not work. Make sure that the buffer is flushed before starting to load bytes. Also, if multiple bytes are loaded into the same location, they will be ANDed together, thus 0x55 and 0xAA will result in 0x00 in the buffer.</p>
<dl class="section note"><dt>Note:</dt><dd>Only one page buffer exist, thus only one page can be loaded with data and programmed into one page. If data needs to be written to different pages, the loading and writing needs to be repeated.</dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_addr</td><td>EEPROM Byte address, between 0 and EEPROM_PAGE_SIZE. </td></tr>
    <tr><td class="paramname">value</td><td>Byte value to write to buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga02f10adbf959b8525bbaf777ad6e43b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_load_page_to_buffer </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load entire page into temporary EEPROM page buffer. </p>
<p>This function loads an entire EEPROM page from an SRAM buffer to the EEPROM page buffers. If memory mapped EEPROM is enabled, this function will not work. Make sure that the buffer is flushed before starting to load bytes.</p>
<dl class="section note"><dt>Note:</dt><dd>Only the lower part of the address is used to address the buffer. Therefore, no address parameter is needed. In the end, the data is written to the EEPROM page given by the address parameter to the EEPROM write page operation.</dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Pointer to SRAM buffer containing an entire page. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga723a1c1ef60ffb4d220f28c99e6c3014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_read_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvm__eeprom__group.html#ga9adfe2ae9400336ec4a715b2db1c3e79">eeprom_addr_t</a>&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read buffer within the eeprom. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>the address to where to read </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to the data </td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f2c4c625ef21cd65891d480f7e6e6b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t nvm_eeprom_read_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvm__eeprom__group.html#ga9adfe2ae9400336ec4a715b2db1c3e79">eeprom_addr_t</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one byte from EEPROM using mapped access. </p>
<p>This function reads one byte from EEPROM using mapped access.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>EEPROM address, between 0 and EEPROM_SIZE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Byte value read from EEPROM. </dd></dl>

</div>
</div>
<a class="anchor" id="gae8b5ca90e2d370109bed6e6adc8d9307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_split_write_page </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>page_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write (without erasing) EEPROM page. </p>
<p>This function writes the contents of an already loaded EEPROM page buffer into EEPROM memory.</p>
<p>As this is a split write, the page in EEPROM will <em>not</em> be erased before writing.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_addr</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga683292d1a734f3222e18720ac66f2315"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_eeprom_write_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvm__eeprom__group.html#ga9adfe2ae9400336ec4a715b2db1c3e79">eeprom_addr_t</a>&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write one byte to EEPROM using IO mapping. </p>
<p>This function writes one byte to EEPROM using IO-mapped access. This function will cancel all ongoing EEPROM page buffer loading operations, if any.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>EEPROM address (max EEPROM_SIZE) </td></tr>
    <tr><td class="paramname">value</td><td>Byte value to write to EEPROM. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 10 2017 23:17:49 for OnePos by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
